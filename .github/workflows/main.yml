# This is a basic workflow to help you get started with Actions

name: CI_v3

# Controls when the workflow will run
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # Job#1
  acrn_clang_tidy_job:
    runs-on: self-hosted
    steps:
       - uses: actions/checkout@v2
         with:
           fetch-depth: 0
       - name: Run scan
         run: |
           echo "start to check code styles and typos ..."
           cd hypervisor
           make codescan
#   Job#2
#   checkpatch_job:
#     runs-on: self-hosted
#     steps:
#       - name: Run scan2
#         if : [ pull_request ]
#         run: |
#           echo "start to check code styles and typos ..."
#           pwd
#           git status
#           git rev-list `git merge-base HEAD origin/main` | xargs -n 1 checkpatch.pl --notree --codespell -g
      
  # Job#3
  build_job:
    runs-on: self-hosted
    steps:
      - name: build
        run: |
          echo "start to build ..."
          pwd
          python3 /opt/actions/modify_bootargs.py first
          cd hypervisor
          make clean
          sh /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "make RELEASE=0 && ls ../"
          if [ $? -ne 0 ]; then exit 1; fi
    needs:
      acrn_clang_tidy_job
  
  # Job#4  
  test_srs_build_job:
    runs-on: self-hosted
    steps:
      - name: test
        run: |
         echo "start to test srs lauching acrn unit test ..."
          pwd
          cd ../acrn-hypervisor/
          git reset --hard && git checkout master && git pull
          python3 /opt/actions/modify_script.py vm1
          cd hypervisor
          make clean
          /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "make RELEASE=0"
          if [ $? -ne 0 ]; then exit 1; fi
          mv build/acrn.32.out /var/lib/tftpboot/acrn_srs/srs/acrn_pci_vm1.32.out
          git reset --hard && git checkout master && git pull
          python3 /opt/actions/modify_script.py vm0
          make clean
          /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "make RELEASE=0"
          mv build/acrn.32.out /var/lib/tftpboot/acrn_srs/srs/acrn_pci_vm0.32.out
          git reset --hard && git checkout master && git pull
          python3 /opt/actions/compile_case_hv_ram_start.py
           make clean
          /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "make RELEASE=0"
          mv build/acrn.32.out /var/lib/tftpboot/acrn_srs/srs/acrn_hv_ram.32.out
          git reset --hard && git checkout master && git pull
          python3 /opt/actions/modify_script_safety_ananysis.py
          make clean
          /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "make RELEASE=0"
          mv build/acrn.32.out /var/lib/tftpboot/acrn_srs/srs/acrn_low_direct.32.out
          git reset --hard && git checkout master && git pull
          make clean
          /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "make RELEASE=0"
          if [ $? -ne 0 ]; then exit 1; fi
          mv build/acrn.32.out /var/lib/tftpboot/acrn_srs/srs/acrn.32.out
          cd ../../acrn-srs-test-code/
          rm -r github
          git reset --hard && git checkout master && git pull
          mkdir github && cd github && git clone https://github.com/projectacrn/acrn-unit-test.git
          cp -r ../acrn-unit-test/* acrn-unit-test/
          cd acrn-unit-test/guest/
          /opt/acrn-ebtool/docker_run.sh ubuntu:v3.0 "./make_all.sh"
          if [ $? -ne 0 ]; then exit 1; fi
          cp -r x86/obj/* /var/lib/tftpboot/acrn_srs/acrn/
          cp x86/memory_order_single_case.bzimage /var/lib/tftpboot/acrn_srs/acrn/
          cd ../../../../acrn-sliced-mainline
          /opt/fusa_ci.sh launch_acrn_unit_test
    if: ${{ always() }}
    needs:
      build_job
